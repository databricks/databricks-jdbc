<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>VolumeOperationExecutor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jacoco.exec</a> &gt; <a href="index.source.html" class="el_package">com.databricks.jdbc.core</a> &gt; <span class="el_source">VolumeOperationExecutor.java</span></div><h1>VolumeOperationExecutor.java</h1><pre class="source lang-java linenums">package com.databricks.jdbc.core;

import com.databricks.jdbc.client.DatabricksHttpException;
import com.databricks.jdbc.client.IDatabricksHttpClient;
import com.databricks.jdbc.client.sqlexec.ExternalLink;
import java.io.*;
import java.util.*;
import org.apache.http.HttpEntity;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpDelete;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPut;
import org.apache.http.entity.ContentType;
import org.apache.http.entity.FileEntity;
import org.apache.http.util.EntityUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/** Executor for volume operations */
class VolumeOperationExecutor implements Runnable {

<span class="fc" id="L22">  private static final Logger LOGGER = LogManager.getLogger(VolumeOperationExecutor.class);</span>

  private static final String COMMA_SEPARATOR = &quot;,&quot;;
  private static final String PARENT_DIRECTORY_REF = &quot;..&quot;;
  private static final String GET_OPERATION = &quot;get&quot;;
  private static final String PUT_OPERATION = &quot;put&quot;;
  private static final String REMOVE_OPERATION = &quot;remove&quot;;

<span class="fc" id="L30">  private static final Long PUT_SIZE_LIMITS = 5 * 1024 * 1024 * 1024L; // 5GB</span>
  private final String operationType;
  private final String operationUrl;
  private final String localFilePath;
  private final Map&lt;String, String&gt; headers;
  private final Set&lt;String&gt; allowedVolumeIngestionPaths;
  private VolumeOperationStatus status;
  private IDatabricksHttpClient databricksHttpClient;
  private String errorMessage;

  VolumeOperationExecutor(
      String operationType,
      ExternalLink externalLink,
      String localFilePath,
      String allowedVolumeIngestionPathString,
<span class="fc" id="L45">      IDatabricksHttpClient databricksHttpClient) {</span>
<span class="fc" id="L46">    this.operationType = operationType;</span>
<span class="fc bfc" id="L47" title="All 2 branches covered.">    this.operationUrl = externalLink == null ? null : externalLink.getExternalLink();</span>
<span class="fc" id="L48">    this.localFilePath = localFilePath;</span>
<span class="fc bfc" id="L49" title="All 2 branches covered.">    this.headers = externalLink == null ? Collections.emptyMap() : externalLink.getHttpHeaders();</span>
<span class="fc" id="L50">    this.allowedVolumeIngestionPaths = getAllowedPaths(allowedVolumeIngestionPathString);</span>
<span class="fc" id="L51">    this.databricksHttpClient = databricksHttpClient;</span>
<span class="fc" id="L52">    this.status = VolumeOperationStatus.PENDING;</span>
<span class="fc" id="L53">    this.errorMessage = null;</span>
<span class="fc" id="L54">  }</span>

  private static Set&lt;String&gt; getAllowedPaths(String allowedVolumeIngestionPathString) {
<span class="pc bpc" id="L57" title="1 of 4 branches missed.">    if (allowedVolumeIngestionPathString == null || allowedVolumeIngestionPathString.isEmpty()) {</span>
<span class="fc" id="L58">      return Collections.emptySet();</span>
    }
<span class="fc" id="L60">    return new HashSet&lt;&gt;(Arrays.asList(allowedVolumeIngestionPathString.split(COMMA_SEPARATOR)));</span>
  }

  @Override
  public void run() {
<span class="fc" id="L65">    LOGGER.debug(</span>
        &quot;Running volume operation {} on local file {}&quot;,
        operationType,
<span class="fc bfc" id="L68" title="All 2 branches covered.">        localFilePath == null ? &quot;&quot; : localFilePath);</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">    if (operationUrl == null) {</span>
<span class="fc" id="L70">      LOGGER.error(&quot;Volume operation URL is not set&quot;);</span>
<span class="fc" id="L71">      status = VolumeOperationStatus.ABORTED;</span>
<span class="fc" id="L72">      errorMessage = &quot;Volume operation URL is not set&quot;;</span>
<span class="fc" id="L73">      return;</span>
    }
<span class="fc" id="L75">    validateLocalFilePath();</span>
<span class="fc bfc" id="L76" title="All 2 branches covered.">    if (status == VolumeOperationStatus.ABORTED) {</span>
<span class="fc" id="L77">      return;</span>
    }
<span class="fc" id="L79">    status = VolumeOperationStatus.RUNNING;</span>
<span class="fc bfc" id="L80" title="All 4 branches covered.">    switch (operationType.toLowerCase()) {</span>
      case GET_OPERATION:
<span class="fc" id="L82">        executeGetOperation();</span>
<span class="fc" id="L83">        break;</span>
      case PUT_OPERATION:
<span class="fc" id="L85">        executePutOperation();</span>
<span class="fc" id="L86">        break;</span>
      case REMOVE_OPERATION:
<span class="fc" id="L88">        executeDeleteOperation();</span>
<span class="fc" id="L89">        break;</span>
      default:
<span class="fc" id="L91">        status = VolumeOperationStatus.ABORTED;</span>
<span class="fc" id="L92">        errorMessage = &quot;Invalid operation type&quot;;</span>
    }
<span class="fc" id="L94">  }</span>

  VolumeOperationStatus getStatus() {
<span class="fc" id="L97">    return status;</span>
  }

  String getErrorMessage() {
<span class="fc" id="L101">    return errorMessage;</span>
  }

  private void validateLocalFilePath() {
<span class="fc bfc" id="L105" title="All 2 branches covered.">    if (allowedVolumeIngestionPaths.isEmpty()) {</span>
<span class="fc" id="L106">      LOGGER.error(&quot;Volume ingestion paths are not set&quot;);</span>
<span class="fc" id="L107">      status = VolumeOperationStatus.ABORTED;</span>
<span class="fc" id="L108">      errorMessage = &quot;Volume operation not supported&quot;;</span>
<span class="fc" id="L109">      return;</span>
    }
<span class="fc bfc" id="L111" title="All 2 branches covered.">    if (operationType.equalsIgnoreCase(REMOVE_OPERATION)) {</span>
<span class="fc" id="L112">      return;</span>
    }
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">    if (localFilePath == null</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">        || localFilePath.isEmpty()</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">        || localFilePath.contains(PARENT_DIRECTORY_REF)) {</span>
<span class="fc" id="L117">      LOGGER.error(&quot;Local file path is invalid {}&quot;, localFilePath);</span>
<span class="fc" id="L118">      status = VolumeOperationStatus.ABORTED;</span>
<span class="fc" id="L119">      errorMessage = &quot;Local file path is invalid&quot;;</span>
<span class="fc" id="L120">      return;</span>
    }
<span class="fc" id="L122">    Optional&lt;Boolean&gt; pathMatched =</span>
<span class="fc" id="L123">        allowedVolumeIngestionPaths.stream()</span>
<span class="fc" id="L124">            .map(localFilePath::startsWith)</span>
<span class="fc" id="L125">            .filter(x -&gt; x)</span>
<span class="fc" id="L126">            .findFirst();</span>
<span class="pc bpc" id="L127" title="1 of 4 branches missed.">    if (pathMatched.isEmpty() || !pathMatched.get()) {</span>
<span class="fc" id="L128">      LOGGER.error(&quot;Local file path is not allowed {}&quot;, localFilePath);</span>
<span class="fc" id="L129">      status = VolumeOperationStatus.ABORTED;</span>
<span class="fc" id="L130">      errorMessage = &quot;Local file path is not allowed&quot;;</span>
    }
<span class="fc" id="L132">  }</span>

  private void executeGetOperation() {
<span class="fc" id="L135">    HttpGet httpGet = new HttpGet(operationUrl);</span>
<span class="fc" id="L136">    headers.forEach(httpGet::addHeader);</span>

<span class="fc" id="L138">    File localFile = new File(localFilePath);</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">    if (localFile.exists()) {</span>
<span class="fc" id="L140">      LOGGER.error(&quot;Local file already exists for GET operation {}&quot;, localFilePath);</span>
<span class="fc" id="L141">      status = VolumeOperationStatus.ABORTED;</span>
<span class="fc" id="L142">      errorMessage = &quot;Local file already exists&quot;;</span>
<span class="fc" id="L143">      return;</span>
    }

<span class="fc" id="L146">    try (CloseableHttpResponse response = databricksHttpClient.execute(httpGet)) {</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">      if (!isSuccessfulHttpResponse(response)) {</span>
<span class="fc" id="L148">        LOGGER.error(</span>
            &quot;Failed to fetch content from volume with error {} for local file {}&quot;,
<span class="fc" id="L150">            response.getStatusLine().getStatusCode(),</span>
            localFilePath);
<span class="fc" id="L152">        status = VolumeOperationStatus.FAILED;</span>
<span class="fc" id="L153">        errorMessage = &quot;Failed to download file&quot;;</span>
<span class="fc" id="L154">        return;</span>
      }
<span class="fc" id="L156">      HttpEntity entity = response.getEntity();</span>
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">      if (entity != null) {</span>
        // Get the content of the HttpEntity
<span class="fc" id="L159">        InputStream inputStream = entity.getContent();</span>
        // Create a FileOutputStream to write the content to a file
<span class="fc" id="L161">        try (FileOutputStream outputStream = new FileOutputStream(localFile)) {</span>
          // Copy the content of the InputStream to the FileOutputStream
<span class="fc" id="L163">          byte[] buffer = new byte[1024];</span>
          int length;
<span class="fc bfc" id="L165" title="All 2 branches covered.">          while ((length = inputStream.read(buffer)) != -1) {</span>
<span class="fc" id="L166">            outputStream.write(buffer, 0, length);</span>
          }
<span class="fc" id="L168">          status = VolumeOperationStatus.SUCCEEDED;</span>
<span class="nc" id="L169">        } catch (FileNotFoundException e) {</span>
<span class="nc" id="L170">          LOGGER.error(&quot;Local file path is invalid or a directory {}&quot;, localFilePath);</span>
<span class="nc" id="L171">          status = VolumeOperationStatus.FAILED;</span>
<span class="nc" id="L172">          errorMessage = &quot;Local file path is invalid or a directory&quot;;</span>
<span class="nc" id="L173">        } catch (IOException e) {</span>
          // TODO: handle retries
<span class="nc" id="L175">          LOGGER.error(</span>
<span class="nc" id="L176">              &quot;Failed to write to local file {} with error {}&quot;, localFilePath, e.getMessage());</span>
<span class="nc" id="L177">          status = VolumeOperationStatus.FAILED;</span>
<span class="nc" id="L178">          errorMessage = &quot;Failed to write to local file: &quot; + e.getMessage();</span>
        } finally {
          // It's important to consume the entity content fully and ensure the stream is closed
<span class="fc" id="L181">          EntityUtils.consume(entity);</span>
        }
      }
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">    } catch (IOException | DatabricksHttpException e) {</span>
<span class="nc" id="L185">      status = VolumeOperationStatus.FAILED;</span>
<span class="nc" id="L186">      errorMessage = &quot;Failed to download file: &quot; + e.getMessage();</span>
<span class="fc" id="L187">    }</span>
<span class="fc" id="L188">  }</span>

  private void executePutOperation() {
<span class="fc" id="L191">    HttpPut httpPut = new HttpPut(operationUrl);</span>
<span class="fc" id="L192">    headers.forEach(httpPut::addHeader);</span>

    // Set the FileEntity as the request body
<span class="fc" id="L195">    File file = new File(localFilePath);</span>
<span class="pc bpc" id="L196" title="1 of 4 branches missed.">    if (!file.exists() || file.isDirectory()) {</span>
<span class="fc" id="L197">      LOGGER.error(&quot;Local file does not exist or is a directory {}&quot;, localFilePath);</span>
<span class="fc" id="L198">      status = VolumeOperationStatus.ABORTED;</span>
<span class="fc" id="L199">      errorMessage = &quot;Local file does not exist or is a directory&quot;;</span>
<span class="fc" id="L200">      return;</span>
    }
<span class="fc bfc" id="L202" title="All 2 branches covered.">    if (file.length() == 0) {</span>
<span class="fc" id="L203">      LOGGER.error(&quot;Local file is empty {}&quot;, localFilePath);</span>
<span class="fc" id="L204">      status = VolumeOperationStatus.ABORTED;</span>
<span class="fc" id="L205">      errorMessage = &quot;Local file is empty&quot;;</span>
<span class="fc" id="L206">      return;</span>
    }

<span class="pc bpc" id="L209" title="1 of 2 branches missed.">    if (file.length() &gt; PUT_SIZE_LIMITS) {</span>
<span class="nc" id="L210">      LOGGER.error(&quot;Local file too large {}&quot;, localFilePath);</span>
<span class="nc" id="L211">      status = VolumeOperationStatus.ABORTED;</span>
<span class="nc" id="L212">      errorMessage = &quot;Local file too large&quot;;</span>
<span class="nc" id="L213">      return;</span>
    }

<span class="fc" id="L216">    FileEntity fileEntity = new FileEntity(file, ContentType.DEFAULT_BINARY);</span>
<span class="fc" id="L217">    httpPut.setEntity(fileEntity);</span>

    // Execute the request
<span class="fc" id="L220">    try (CloseableHttpResponse response = databricksHttpClient.execute(httpPut)) {</span>
      // Process the response
<span class="fc bfc" id="L222" title="All 2 branches covered.">      if (isSuccessfulHttpResponse(response)) {</span>
<span class="fc" id="L223">        status = VolumeOperationStatus.SUCCEEDED;</span>
      } else {
<span class="fc" id="L225">        LOGGER.error(</span>
            &quot;Failed to upload file {} with error code: {}&quot;,
            localFilePath,
<span class="fc" id="L228">            response.getStatusLine().getStatusCode());</span>
        // TODO: handle retries
<span class="fc" id="L230">        status = VolumeOperationStatus.FAILED;</span>
<span class="fc" id="L231">        errorMessage =</span>
<span class="fc" id="L232">            &quot;Failed to upload file with error code: &quot; + response.getStatusLine().getStatusCode();</span>
      }
<span class="nc" id="L234">    } catch (IOException | DatabricksHttpException e) {</span>
<span class="nc" id="L235">      LOGGER.error(&quot;Failed to upload file {} with error {}&quot;, localFilePath, e.getMessage());</span>
<span class="nc" id="L236">      status = VolumeOperationStatus.FAILED;</span>
<span class="nc" id="L237">      errorMessage = &quot;Failed to upload file: &quot; + e.getMessage();</span>
<span class="fc" id="L238">    }</span>
<span class="fc" id="L239">  }</span>

  private void executeDeleteOperation() {
    // TODO: Check for AWS specific handling
<span class="fc" id="L243">    HttpDelete httpDelete = new HttpDelete(operationUrl);</span>
<span class="fc" id="L244">    headers.forEach(httpDelete::addHeader);</span>
<span class="fc" id="L245">    try (CloseableHttpResponse response = databricksHttpClient.execute(httpDelete)) {</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">      if (isSuccessfulHttpResponse(response)) {</span>
<span class="fc" id="L247">        status = VolumeOperationStatus.SUCCEEDED;</span>
      } else {
<span class="fc" id="L249">        LOGGER.error(</span>
            &quot;Failed to delete volume with error code: {}&quot;,
<span class="fc" id="L251">            response.getStatusLine().getStatusCode());</span>
<span class="fc" id="L252">        status = VolumeOperationStatus.FAILED;</span>
<span class="fc" id="L253">        errorMessage = &quot;Failed to delete volume&quot;;</span>
      }
<span class="nc" id="L255">    } catch (DatabricksHttpException | IOException e) {</span>
<span class="nc" id="L256">      LOGGER.error(&quot;Failed to delete volume with error {}&quot;, e.getMessage());</span>
<span class="nc" id="L257">      status = VolumeOperationStatus.FAILED;</span>
<span class="nc" id="L258">      errorMessage = &quot;Failed to delete volume: &quot; + e.getMessage();</span>
<span class="fc" id="L259">    }</span>
<span class="fc" id="L260">  }</span>

  private boolean isSuccessfulHttpResponse(CloseableHttpResponse response) {
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">    return response.getStatusLine().getStatusCode() &gt;= 200</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">        &amp;&amp; response.getStatusLine().getStatusCode() &lt; 300;</span>
  }

<span class="fc" id="L267">  static enum VolumeOperationStatus {</span>
<span class="fc" id="L268">    PENDING,</span>
<span class="fc" id="L269">    RUNNING,</span>
<span class="fc" id="L270">    ABORTED,</span>
<span class="fc" id="L271">    SUCCEEDED,</span>
<span class="fc" id="L272">    FAILED;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>