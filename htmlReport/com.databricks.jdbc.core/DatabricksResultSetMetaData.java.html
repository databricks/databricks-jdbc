<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DatabricksResultSetMetaData.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jacoco.exec</a> &gt; <a href="index.source.html" class="el_package">com.databricks.jdbc.core</a> &gt; <span class="el_source">DatabricksResultSetMetaData.java</span></div><h1>DatabricksResultSetMetaData.java</h1><pre class="source lang-java linenums">package com.databricks.jdbc.core;

import static com.databricks.jdbc.client.impl.thrift.commons.DatabricksThriftHelper.getTypeFromTypeDesc;
import static com.databricks.jdbc.driver.DatabricksJdbcConstants.VOLUME_OPERATION_STATUS_COLUMN_NAME;

import com.databricks.jdbc.client.impl.thrift.generated.TColumnDesc;
import com.databricks.jdbc.client.impl.thrift.generated.TGetResultSetMetadataResp;
import com.databricks.jdbc.client.sqlexec.ResultData;
import com.databricks.jdbc.client.sqlexec.ResultManifest;
import com.databricks.jdbc.commons.util.WrapperUtil;
import com.databricks.jdbc.core.types.AccessType;
import com.databricks.jdbc.core.types.Nullable;
import com.databricks.sdk.service.sql.ColumnInfo;
import com.databricks.sdk.service.sql.ColumnInfoTypeName;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Types;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class DatabricksResultSetMetaData implements ResultSetMetaData {

<span class="fc" id="L28">  private static final Logger LOGGER = LogManager.getLogger(DatabricksResultSetMetaData.class);</span>
  private final String statementId;
  private final ImmutableList&lt;ImmutableDatabricksColumn&gt; columns;
  private final ImmutableMap&lt;String, Integer&gt; columnNameIndex;
  private final long totalRows;
  private Long chunkCount;
  private static final String DEFAULT_CATALOGUE_NAME = &quot;Spark&quot;;
  private static final String NULL_STRING = &quot;null&quot;;

  // TODO: Add handling for Arrow stream results

  public DatabricksResultSetMetaData(
<span class="fc" id="L40">      String statementId, ResultManifest resultManifest, ResultData resultData) {</span>
<span class="fc" id="L41">    this.statementId = statementId;</span>
<span class="fc" id="L42">    Map&lt;String, Integer&gt; columnNameToIndexMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L43">    ImmutableList.Builder&lt;ImmutableDatabricksColumn&gt; columnsBuilder = ImmutableList.builder();</span>
<span class="fc" id="L44">    LOGGER.debug(</span>
<span class="fc" id="L45">        &quot;Result manifest for statement {} has schema: {}&quot;, statementId, resultManifest.getSchema());</span>

<span class="fc" id="L47">    int currIndex = 0;</span>
<span class="fc bfc" id="L48" title="All 2 branches covered.">    if (resultData.getVolumeOperationInfo() != null) {</span>
<span class="fc" id="L49">      ImmutableDatabricksColumn.Builder columnBuilder = getColumnBuilder();</span>
<span class="fc" id="L50">      columnBuilder</span>
<span class="fc" id="L51">          .columnName(VOLUME_OPERATION_STATUS_COLUMN_NAME)</span>
<span class="fc" id="L52">          .columnType(Types.VARCHAR)</span>
<span class="fc" id="L53">          .columnTypeText(ColumnInfoTypeName.STRING.name())</span>
<span class="fc" id="L54">          .typePrecision(0)</span>
<span class="fc" id="L55">          .columnTypeClassName(DatabricksTypeUtil.getColumnTypeClassName(ColumnInfoTypeName.STRING))</span>
<span class="fc" id="L56">          .displaySize(DatabricksTypeUtil.getDisplaySize(ColumnInfoTypeName.STRING, 0))</span>
<span class="fc" id="L57">          .isSigned(DatabricksTypeUtil.isSigned(ColumnInfoTypeName.STRING));</span>
<span class="fc" id="L58">      columnsBuilder.add(columnBuilder.build());</span>
<span class="fc" id="L59">      columnNameToIndexMap.putIfAbsent(VOLUME_OPERATION_STATUS_COLUMN_NAME, ++currIndex);</span>
<span class="fc" id="L60">    } else {</span>
<span class="fc bfc" id="L61" title="All 2 branches covered.">      if (resultManifest.getSchema().getColumnCount() &gt; 0) {</span>
<span class="fc bfc" id="L62" title="All 2 branches covered.">        for (ColumnInfo columnInfo : resultManifest.getSchema().getColumns()) {</span>
<span class="fc" id="L63">          ColumnInfoTypeName columnTypeName = columnInfo.getTypeName();</span>
<span class="fc" id="L64">          int precision = DatabricksTypeUtil.getPrecision(columnTypeName);</span>
<span class="fc" id="L65">          ImmutableDatabricksColumn.Builder columnBuilder = getColumnBuilder();</span>
<span class="fc" id="L66">          columnBuilder</span>
<span class="fc" id="L67">              .columnName(columnInfo.getName())</span>
<span class="fc" id="L68">              .columnTypeClassName(DatabricksTypeUtil.getColumnTypeClassName(columnTypeName))</span>
<span class="fc" id="L69">              .columnType(DatabricksTypeUtil.getColumnType(columnTypeName))</span>
<span class="fc" id="L70">              .columnTypeText(columnInfo.getTypeText())</span>
<span class="fc" id="L71">              .typePrecision(precision)</span>
<span class="fc" id="L72">              .displaySize(DatabricksTypeUtil.getDisplaySize(columnTypeName, precision))</span>
<span class="fc" id="L73">              .isSigned(DatabricksTypeUtil.isSigned(columnTypeName));</span>

<span class="fc" id="L75">          columnsBuilder.add(columnBuilder.build());</span>
          // Keep index starting from 1, to be consistent with JDBC convention
<span class="fc" id="L77">          columnNameToIndexMap.putIfAbsent(columnInfo.getName(), ++currIndex);</span>
<span class="fc" id="L78">        }</span>
      }
    }
<span class="fc" id="L81">    this.columns = columnsBuilder.build();</span>
<span class="fc" id="L82">    this.columnNameIndex = ImmutableMap.copyOf(columnNameToIndexMap);</span>
<span class="fc" id="L83">    this.totalRows = resultManifest.getTotalRowCount();</span>
<span class="fc" id="L84">    this.chunkCount = resultManifest.getTotalChunkCount();</span>
<span class="fc" id="L85">  }</span>

  public DatabricksResultSetMetaData(
<span class="fc" id="L88">      String statementId, TGetResultSetMetadataResp resultManifest, long rows, long chunkCount) {</span>
<span class="fc" id="L89">    this.statementId = statementId;</span>
<span class="fc" id="L90">    Map&lt;String, Integer&gt; columnNameToIndexMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L91">    ImmutableList.Builder&lt;ImmutableDatabricksColumn&gt; columnsBuilder = ImmutableList.builder();</span>
<span class="fc" id="L92">    int currIndex = 0;</span>
<span class="pc bpc" id="L93" title="1 of 4 branches missed.">    if (resultManifest.getSchema() != null &amp;&amp; resultManifest.getSchema().getColumnsSize() &gt; 0) {</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">      for (TColumnDesc columnInfo : resultManifest.getSchema().getColumns()) {</span>
<span class="fc" id="L95">        ColumnInfoTypeName columnTypeName = getTypeFromTypeDesc(columnInfo.getTypeDesc());</span>
<span class="fc" id="L96">        int precision = DatabricksTypeUtil.getPrecision(columnTypeName);</span>
<span class="fc" id="L97">        ImmutableDatabricksColumn.Builder columnBuilder = getColumnBuilder();</span>
<span class="fc" id="L98">        columnBuilder</span>
<span class="fc" id="L99">            .columnName(columnInfo.getColumnName())</span>
<span class="fc" id="L100">            .columnTypeClassName(DatabricksTypeUtil.getColumnTypeClassName(columnTypeName))</span>
<span class="fc" id="L101">            .columnType(DatabricksTypeUtil.getColumnType(columnTypeName))</span>
<span class="fc" id="L102">            .columnTypeText(columnTypeName.name())</span>
<span class="fc" id="L103">            .typePrecision(precision)</span>
<span class="fc" id="L104">            .displaySize(DatabricksTypeUtil.getDisplaySize(columnTypeName, precision))</span>
<span class="fc" id="L105">            .isSigned(DatabricksTypeUtil.isSigned(columnTypeName));</span>
<span class="fc" id="L106">        columnsBuilder.add(columnBuilder.build());</span>
<span class="fc" id="L107">        columnNameToIndexMap.putIfAbsent(columnInfo.getColumnName(), ++currIndex);</span>
<span class="fc" id="L108">      }</span>
    }
<span class="fc" id="L110">    this.columns = columnsBuilder.build();</span>
<span class="fc" id="L111">    this.columnNameIndex = ImmutableMap.copyOf(columnNameToIndexMap);</span>
<span class="fc" id="L112">    this.totalRows = rows;</span>
<span class="fc" id="L113">    this.chunkCount = chunkCount;</span>
<span class="fc" id="L114">  }</span>

  public DatabricksResultSetMetaData(
      String statementId,
      List&lt;String&gt; columnNames,
      List&lt;String&gt; columnTypeText,
      List&lt;Integer&gt; columnTypes,
      List&lt;Integer&gt; columnTypePrecisions,
<span class="fc" id="L122">      long totalRows) {</span>
<span class="fc" id="L123">    this.statementId = statementId;</span>

<span class="fc" id="L125">    Map&lt;String, Integer&gt; columnNameToIndexMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L126">    ImmutableList.Builder&lt;ImmutableDatabricksColumn&gt; columnsBuilder = ImmutableList.builder();</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">    for (int i = 0; i &lt; columnNames.size(); i++) {</span>
<span class="fc" id="L128">      ColumnInfoTypeName columnTypeName =</span>
<span class="fc" id="L129">          ColumnInfoTypeName.valueOf(</span>
<span class="fc" id="L130">              DatabricksTypeUtil.getDatabricksTypeFromSQLType(columnTypes.get(i)));</span>
<span class="fc" id="L131">      ImmutableDatabricksColumn.Builder columnBuilder = getColumnBuilder();</span>
<span class="fc" id="L132">      columnBuilder</span>
<span class="fc" id="L133">          .columnName(columnNames.get(i))</span>
<span class="fc" id="L134">          .columnType(columnTypes.get(i))</span>
<span class="fc" id="L135">          .columnTypeText(columnTypeText.get(i))</span>
<span class="fc" id="L136">          .typePrecision(columnTypePrecisions.get(i))</span>
<span class="fc" id="L137">          .columnTypeClassName(DatabricksTypeUtil.getColumnTypeClassName(columnTypeName))</span>
<span class="fc" id="L138">          .displaySize(</span>
<span class="fc" id="L139">              DatabricksTypeUtil.getDisplaySize(columnTypeName, columnTypePrecisions.get(i)))</span>
<span class="fc" id="L140">          .isSigned(DatabricksTypeUtil.isSigned(columnTypeName));</span>
<span class="fc" id="L141">      columnsBuilder.add(columnBuilder.build());</span>
      // Keep index starting from 1, to be consistent with JDBC convention
<span class="fc" id="L143">      columnNameToIndexMap.putIfAbsent(columnNames.get(i), i + 1);</span>
    }
<span class="fc" id="L145">    this.columns = columnsBuilder.build();</span>
<span class="fc" id="L146">    this.columnNameIndex = ImmutableMap.copyOf(columnNameToIndexMap);</span>
<span class="fc" id="L147">    this.totalRows = totalRows;</span>
<span class="fc" id="L148">  }</span>

  @Override
  public int getColumnCount() throws SQLException {
<span class="fc" id="L152">    return columns.size();</span>
  }

  @Override
  public boolean isAutoIncrement(int column) throws SQLException {
<span class="nc" id="L157">    return columns.get(getEffectiveIndex(column)).isAutoIncrement();</span>
  }

  @Override
  public boolean isCaseSensitive(int column) throws SQLException {
<span class="nc" id="L162">    return columns.get(getEffectiveIndex(column)).isCaseSensitive();</span>
  }

  @Override
  public boolean isSearchable(int column) throws SQLException {
<span class="nc" id="L167">    return columns.get(getEffectiveIndex(column)).isSearchable();</span>
  }

  @Override
  public boolean isCurrency(int column) throws SQLException {
<span class="nc" id="L172">    return columns.get(getEffectiveIndex(column)).isCurrency();</span>
  }

  @Override
  public int isNullable(int column) throws SQLException {
<span class="nc" id="L177">    return columns.get(getEffectiveIndex(column)).nullable().getValue();</span>
  }

  @Override
  public boolean isSigned(int column) throws SQLException {
<span class="nc" id="L182">    return columns.get(getEffectiveIndex(column)).isSigned();</span>
  }

  @Override
  public int getColumnDisplaySize(int column) throws SQLException {
<span class="nc" id="L187">    return columns.get(getEffectiveIndex(column)).displaySize();</span>
  }

  @Override
  public String getColumnLabel(int column) throws SQLException {
<span class="nc" id="L192">    return columns.get(getEffectiveIndex(column)).columnName();</span>
  }

  @Override
  public String getColumnName(int column) throws SQLException {
<span class="fc" id="L197">    return columns.get(getEffectiveIndex(column)).columnName();</span>
  }

  @Override
  public String getSchemaName(int column) throws SQLException {
<span class="nc" id="L202">    return columns.get(getEffectiveIndex(column)).schemaName();</span>
  }

  @Override
  public int getPrecision(int column) throws SQLException {
<span class="nc" id="L207">    return columns.get(getEffectiveIndex(column)).typePrecision();</span>
  }

  @Override
  public int getScale(int column) throws SQLException {
<span class="nc" id="L212">    return columns.get(getEffectiveIndex(column)).typeScale();</span>
  }

  @Override
  public String getTableName(int column) throws SQLException {
<span class="nc" id="L217">    return columns.get(getEffectiveIndex(column)).tableName();</span>
  }

  @Override
  public String getCatalogName(int column) throws SQLException {
<span class="nc" id="L222">    return columns.get(getEffectiveIndex(column)).catalogName();</span>
  }

  @Override
  public int getColumnType(int column) throws SQLException {
<span class="nc" id="L227">    return columns.get(getEffectiveIndex(column)).columnType();</span>
  }

  @Override
  public String getColumnTypeName(int column) throws SQLException {
<span class="nc" id="L232">    return columns.get(getEffectiveIndex(column)).columnTypeText();</span>
  }

  @Override
  public boolean isReadOnly(int column) throws SQLException {
<span class="nc" id="L237">    AccessType columnAccessType = columns.get(getEffectiveIndex(column)).accessType();</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">    return columnAccessType.equals(AccessType.READ_ONLY)</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">        || columnAccessType.equals(AccessType.UNKNOWN);</span>
  }

  @Override
  public boolean isWritable(int column) throws SQLException {
<span class="nc" id="L244">    return columns.get(getEffectiveIndex(column)).accessType().equals(AccessType.WRITE);</span>
  }

  @Override
  public boolean isDefinitelyWritable(int column) throws SQLException {
<span class="nc" id="L249">    return columns.get(getEffectiveIndex(column)).isDefinitelyWritable();</span>
  }

  @Override
  public String getColumnClassName(int column) throws SQLException {
<span class="nc" id="L254">    return columns.get(getEffectiveIndex(column)).columnTypeClassName();</span>
  }

  @Override
  public &lt;T&gt; T unwrap(Class&lt;T&gt; iface) throws SQLException {
<span class="nc" id="L259">    return WrapperUtil.unwrap(iface, this);</span>
  }

  @Override
  public boolean isWrapperFor(Class&lt;?&gt; iface) throws SQLException {
<span class="nc" id="L264">    return WrapperUtil.isWrapperFor(iface, this);</span>
  }

  private int getEffectiveIndex(int columnIndex) {
<span class="pc bpc" id="L268" title="2 of 4 branches missed.">    if (columnIndex &gt; 0 &amp;&amp; columnIndex &lt;= columns.size()) {</span>
<span class="fc" id="L269">      return columnIndex - 1;</span>
    } else {
<span class="nc" id="L271">      throw new IllegalStateException(&quot;Invalid column index: &quot; + columnIndex);</span>
    }
  }

  /**
   * Returns index of column-name in metadata starting from 1
   *
   * @param columnName column-name
   * @return index of column if exists, else -1
   */
  public int getColumnNameIndex(String columnName) {
<span class="fc" id="L282">    return columnNameIndex.getOrDefault(columnName, -1);</span>
  }

  public long getTotalRows() {
<span class="fc" id="L286">    return totalRows;</span>
  }

  public Long getChunkCount() {
<span class="nc" id="L290">    return chunkCount;</span>
  }

  private ImmutableDatabricksColumn.Builder getColumnBuilder() {
<span class="fc" id="L294">    return ImmutableDatabricksColumn.builder()</span>
<span class="fc" id="L295">        .isAutoIncrement(false)</span>
<span class="fc" id="L296">        .isSearchable(true)</span>
<span class="fc" id="L297">        .nullable(Nullable.NULLABLE)</span>
<span class="fc" id="L298">        .accessType(AccessType.READ_ONLY)</span>
<span class="fc" id="L299">        .isDefinitelyWritable(false)</span>
<span class="fc" id="L300">        .schemaName(NULL_STRING)</span>
<span class="fc" id="L301">        .tableName(NULL_STRING)</span>
<span class="fc" id="L302">        .catalogName(DEFAULT_CATALOGUE_NAME)</span>
<span class="fc" id="L303">        .isCurrency(false)</span>
<span class="fc" id="L304">        .typeScale(0)</span>
<span class="fc" id="L305">        .isCaseSensitive(false);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>