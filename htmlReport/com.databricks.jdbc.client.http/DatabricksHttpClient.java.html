<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DatabricksHttpClient.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jacoco.exec</a> &gt; <a href="index.source.html" class="el_package">com.databricks.jdbc.client.http</a> &gt; <span class="el_source">DatabricksHttpClient.java</span></div><h1>DatabricksHttpClient.java</h1><pre class="source lang-java linenums">package com.databricks.jdbc.client.http;

import static com.databricks.jdbc.driver.DatabricksJdbcConstants.FAKE_SERVICE_URI_PROP_SUFFIX;
import static com.databricks.jdbc.driver.DatabricksJdbcConstants.IS_FAKE_SERVICE_TEST_PROP;
import static io.netty.util.NetUtil.LOCALHOST;

import com.databricks.jdbc.client.DatabricksHttpException;
import com.databricks.jdbc.client.IDatabricksHttpClient;
import com.databricks.jdbc.driver.IDatabricksConnectionContext;
import com.databricks.sdk.core.UserAgent;
import com.google.common.annotations.VisibleForTesting;
import java.io.IOException;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import org.apache.http.HttpException;
import org.apache.http.HttpHost;
import org.apache.http.HttpResponse;
import org.apache.http.HttpResponseInterceptor;
import org.apache.http.auth.AuthScope;
import org.apache.http.auth.UsernamePasswordCredentials;
import org.apache.http.client.CredentialsProvider;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpUriRequest;
import org.apache.http.client.protocol.HttpClientContext;
import org.apache.http.conn.UnsupportedSchemeException;
import org.apache.http.conn.routing.HttpRoute;
import org.apache.http.impl.client.BasicCredentialsProvider;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClientBuilder;
import org.apache.http.impl.client.ProxyAuthenticationStrategy;
import org.apache.http.impl.conn.DefaultSchemePortResolver;
import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;
import org.apache.http.protocol.HttpContext;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/** Http client implementation to be used for executing http requests. */
public class DatabricksHttpClient implements IDatabricksHttpClient {

<span class="fc" id="L43">  private static final Logger LOGGER = LogManager.getLogger(DatabricksHttpClient.class);</span>

  // TODO(PECO-1373): Revisit number of connections and connections per route.
  private static final int DEFAULT_MAX_HTTP_CONNECTIONS = 1000;
  private static final int DEFAULT_MAX_HTTP_CONNECTIONS_PER_ROUTE = 1000;
  private static final int DEFAULT_HTTP_CONNECTION_TIMEOUT = 60 * 1000; // ms
  private static final int DEFAULT_HTTP_CLIENT_SOCKET_TIMEOUT = 300 * 1000; // ms
  private static final int DEFAULT_BACKOFF_FACTOR = 2; // Exponential factor
  private static final int MIN_BACKOFF_INTERVAL = 1000; // 1s
  private static final int MAX_RETRY_INTERVAL = 10 * 1000; // 10s
  private static final int DEFAULT_RETRY_COUNT = 5;
  private static final String HTTP_GET = &quot;GET&quot;;
  private static final String SDK_USER_AGENT = &quot;databricks-sdk-java&quot;;
  private static final String JDBC_HTTP_USER_AGENT = &quot;databricks-jdbc-http&quot;;
<span class="fc" id="L57">  private static final Set&lt;Integer&gt; RETRYABLE_HTTP_CODES = getRetryableHttpCodes();</span>
  protected static final long DEFAULT_IDLE_CONNECTION_TIMEOUT = 5;

<span class="fc" id="L60">  private static DatabricksHttpClient instance = null;</span>

  private static PoolingHttpClientConnectionManager connectionManager;

  private final CloseableHttpClient httpClient;

<span class="fc" id="L66">  private DatabricksHttpClient(IDatabricksConnectionContext connectionContext) {</span>
<span class="fc" id="L67">    connectionManager = new PoolingHttpClientConnectionManager();</span>
<span class="fc" id="L68">    connectionManager.setMaxTotal(DEFAULT_MAX_HTTP_CONNECTIONS);</span>
<span class="fc" id="L69">    connectionManager.setDefaultMaxPerRoute(DEFAULT_MAX_HTTP_CONNECTIONS_PER_ROUTE);</span>
<span class="fc" id="L70">    httpClient = makeClosableHttpClient(connectionContext);</span>
<span class="fc" id="L71">  }</span>

  @VisibleForTesting
  DatabricksHttpClient(
      CloseableHttpClient closeableHttpClient,
<span class="fc" id="L76">      PoolingHttpClientConnectionManager connectionManager) {</span>
<span class="fc" id="L77">    DatabricksHttpClient.connectionManager = connectionManager;</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">    if (connectionManager != null) {</span>
<span class="fc" id="L79">      connectionManager.setMaxTotal(DEFAULT_MAX_HTTP_CONNECTIONS);</span>
<span class="fc" id="L80">      connectionManager.setDefaultMaxPerRoute(DEFAULT_MAX_HTTP_CONNECTIONS_PER_ROUTE);</span>
    }
<span class="fc" id="L82">    httpClient = closeableHttpClient;</span>
<span class="fc" id="L83">  }</span>

  private RequestConfig makeRequestConfig() {
<span class="fc" id="L86">    return RequestConfig.custom()</span>
<span class="fc" id="L87">        .setConnectionRequestTimeout(DEFAULT_HTTP_CONNECTION_TIMEOUT)</span>
<span class="fc" id="L88">        .setConnectTimeout(DEFAULT_HTTP_CONNECTION_TIMEOUT)</span>
<span class="fc" id="L89">        .setSocketTimeout(DEFAULT_HTTP_CLIENT_SOCKET_TIMEOUT)</span>
<span class="fc" id="L90">        .build();</span>
  }

  private static Set&lt;Integer&gt; getRetryableHttpCodes() {
<span class="fc" id="L94">    Set&lt;Integer&gt; retryableCodes = new HashSet&lt;&gt;();</span>
<span class="fc" id="L95">    retryableCodes.add(408); // request timeout</span>
<span class="fc" id="L96">    retryableCodes.add(425); // too early response</span>
<span class="fc" id="L97">    retryableCodes.add(429); // too many requests</span>
<span class="fc" id="L98">    retryableCodes.add(500); // internal server error</span>
<span class="fc" id="L99">    retryableCodes.add(502); // bad gateway (should this be retried?)</span>
<span class="fc" id="L100">    retryableCodes.add(503); // service unavailable</span>
<span class="fc" id="L101">    retryableCodes.add(504); // gateway timeout</span>
<span class="fc" id="L102">    return retryableCodes;</span>
  }

  private CloseableHttpClient makeClosableHttpClient(
      IDatabricksConnectionContext connectionContext) {
    HttpClientBuilder builder =
<span class="fc" id="L108">        HttpClientBuilder.create()</span>
<span class="fc" id="L109">            .setConnectionManager(connectionManager)</span>
<span class="fc" id="L110">            .setUserAgent(getUserAgent())</span>
<span class="fc" id="L111">            .setDefaultRequestConfig(makeRequestConfig())</span>
<span class="fc" id="L112">            .setRetryHandler(</span>
                (exception, executionCount, context) -&gt; {
<span class="nc bnc" id="L114" title="All 2 branches missed.">                  if (executionCount &gt; DEFAULT_RETRY_COUNT</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">                      || !isRetryAllowed(</span>
                          ((HttpClientContext) context)
<span class="nc" id="L117">                              .getRequest()</span>
<span class="nc" id="L118">                              .getRequestLine()</span>
<span class="nc" id="L119">                              .getMethod())) {</span>
<span class="nc" id="L120">                    return false;</span>
                  }
<span class="nc" id="L122">                  long nextBackOffDelay =</span>
                      MIN_BACKOFF_INTERVAL
<span class="nc" id="L124">                          * (long) Math.pow(DEFAULT_BACKOFF_FACTOR, executionCount - 1);</span>
<span class="nc" id="L125">                  long delay = Math.min(MAX_RETRY_INTERVAL, nextBackOffDelay);</span>
                  try {
<span class="nc" id="L127">                    Thread.sleep(delay);</span>
<span class="nc" id="L128">                  } catch (InterruptedException e) {</span>
                    // Do nothing
<span class="nc" id="L130">                  }</span>
<span class="nc" id="L131">                  return true;</span>
                })
<span class="fc" id="L133">            .addInterceptorFirst(</span>
<span class="fc" id="L134">                new HttpResponseInterceptor() {</span>
                  // Handling 500 and 503 explicitly for retry
                  @Override
                  public void process(HttpResponse httpResponse, HttpContext httpContext)
                      throws HttpException, IOException {
<span class="nc bnc" id="L139" title="All 2 branches missed.">                    if (isErrorCodeRetryable(httpResponse.getStatusLine().getStatusCode())) {</span>
<span class="nc" id="L140">                      throw new IOException(&quot;Retry http request&quot;);</span>
                    }
<span class="nc" id="L142">                  }</span>
                });
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">    if (connectionContext.getUseSystemProxy()) {</span>
<span class="nc" id="L145">      builder.useSystemProperties();</span>
    }
    // Override system proxy if proxy details are explicitly provided
    // If cloud fetch proxy is provided use that, else use the regular proxy
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">    if (connectionContext.getUseCloudFetchProxy()) {</span>
<span class="nc" id="L150">      setProxyDetailsInHttpClient(</span>
          builder,
<span class="nc" id="L152">          connectionContext.getCloudFetchProxyHost(),</span>
<span class="nc" id="L153">          connectionContext.getCloudFetchProxyPort(),</span>
<span class="nc" id="L154">          connectionContext.getUseCloudFetchProxyAuth(),</span>
<span class="nc" id="L155">          connectionContext.getCloudFetchProxyUser(),</span>
<span class="nc" id="L156">          connectionContext.getCloudFetchProxyPassword());</span>
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">    } else if (connectionContext.getUseProxy()) {</span>
<span class="nc" id="L158">      setProxyDetailsInHttpClient(</span>
          builder,
<span class="nc" id="L160">          connectionContext.getProxyHost(),</span>
<span class="nc" id="L161">          connectionContext.getProxyPort(),</span>
<span class="nc" id="L162">          connectionContext.getUseProxyAuth(),</span>
<span class="nc" id="L163">          connectionContext.getProxyUser(),</span>
<span class="nc" id="L164">          connectionContext.getProxyPassword());</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">    } else if (Boolean.parseBoolean(System.getProperty(IS_FAKE_SERVICE_TEST_PROP))) {</span>
<span class="fc" id="L166">      setFakeServiceRouteInHttpClient(builder);</span>
    }

<span class="fc" id="L169">    return builder.build();</span>
  }

  @VisibleForTesting
  public static void setProxyDetailsInHttpClient(
      HttpClientBuilder builder,
      String proxyHost,
      int proxyPort,
      Boolean useProxyAuth,
      String proxyUser,
      String proxyPassword) {
<span class="fc" id="L180">    builder.setProxy(new HttpHost(proxyHost, proxyPort));</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">    if (useProxyAuth) {</span>
<span class="fc" id="L182">      CredentialsProvider credsProvider = new BasicCredentialsProvider();</span>
<span class="fc" id="L183">      credsProvider.setCredentials(</span>
          new AuthScope(proxyHost, proxyPort),
          new UsernamePasswordCredentials(proxyUser, proxyPassword));
<span class="fc" id="L186">      builder</span>
<span class="fc" id="L187">          .setDefaultCredentialsProvider(credsProvider)</span>
<span class="fc" id="L188">          .setProxyAuthenticationStrategy(new ProxyAuthenticationStrategy());</span>
    }
<span class="fc" id="L190">  }</span>

  @VisibleForTesting
  static void setFakeServiceRouteInHttpClient(HttpClientBuilder builder) {
<span class="fc" id="L194">    builder.setRoutePlanner(</span>
        (host, request, context) -&gt; {
          final HttpHost target;
          try {
<span class="fc" id="L198">            target =</span>
                new HttpHost(
<span class="fc" id="L200">                    host.getHostName(),</span>
<span class="fc" id="L201">                    DefaultSchemePortResolver.INSTANCE.resolve(host),</span>
<span class="fc" id="L202">                    host.getSchemeName());</span>
<span class="fc" id="L203">          } catch (UnsupportedSchemeException e) {</span>
<span class="fc" id="L204">            throw new HttpException(e.getMessage());</span>
<span class="fc" id="L205">          }</span>

<span class="fc bfc" id="L207" title="All 2 branches covered.">          if (LOCALHOST.getHostName().equalsIgnoreCase(host.getHostName())) {</span>
            // If the target host is localhost, then no need to set proxy
<span class="fc" id="L209">            return new HttpRoute(target, null, false);</span>
          }

          // Get the fake service URI for the target URI and set it as proxy
<span class="fc" id="L213">          final HttpHost proxy =</span>
<span class="fc" id="L214">              HttpHost.create(System.getProperty(host.toURI() + FAKE_SERVICE_URI_PROP_SUFFIX));</span>

<span class="fc" id="L216">          return new HttpRoute(target, null, proxy, false);</span>
        });
<span class="fc" id="L218">  }</span>

  @VisibleForTesting
  static boolean isRetryAllowed(String method) {
    // For now, allowing retry only for GET which is idempotent
<span class="fc" id="L223">    return Objects.equals(HTTP_GET, method);</span>
  }

  @VisibleForTesting
  static boolean isErrorCodeRetryable(int errCode) {
<span class="fc" id="L228">    return RETRYABLE_HTTP_CODES.contains(errCode);</span>
  }

  public static synchronized DatabricksHttpClient getInstance(
      IDatabricksConnectionContext context) {
<span class="fc bfc" id="L233" title="All 2 branches covered.">    if (instance == null) {</span>
<span class="fc" id="L234">      instance = new DatabricksHttpClient(context);</span>
    }
<span class="fc" id="L236">    return instance;</span>
  }

  @Override
  public CloseableHttpResponse execute(HttpUriRequest request) throws DatabricksHttpException {
<span class="fc" id="L241">    LOGGER.debug(&quot;Executing HTTP request [{}]&quot;, RequestSanitizer.sanitizeRequest(request));</span>
    // TODO: add retries and error handling
    try {
<span class="fc" id="L244">      return httpClient.execute(request);</span>
<span class="fc" id="L245">    } catch (IOException e) {</span>
<span class="fc" id="L246">      String errorMsg =</span>
<span class="fc" id="L247">          String.format(</span>
              &quot;Caught error while executing http request: [%s]&quot;,
<span class="fc" id="L249">              RequestSanitizer.sanitizeRequest(request));</span>
<span class="fc" id="L250">      LOGGER.error(errorMsg, e);</span>
<span class="fc" id="L251">      throw new DatabricksHttpException(errorMsg, e);</span>
    }
  }

  @Override
  public void closeExpiredAndIdleConnections() {
<span class="fc bfc" id="L257" title="All 2 branches covered.">    if (connectionManager != null) {</span>
<span class="fc" id="L258">      synchronized (connectionManager) {</span>
<span class="fc" id="L259">        LOGGER.debug(&quot;connection pool stats: {}&quot;, connectionManager.getTotalStats());</span>
<span class="fc" id="L260">        connectionManager.closeExpiredConnections();</span>
<span class="fc" id="L261">        connectionManager.closeIdleConnections(DEFAULT_IDLE_CONNECTION_TIMEOUT, TimeUnit.SECONDS);</span>
<span class="fc" id="L262">      }</span>
    }
<span class="fc" id="L264">  }</span>

  static String getUserAgent() {
<span class="fc" id="L267">    String sdkUserAgent = UserAgent.asString();</span>
    // Split the string into parts
<span class="fc" id="L269">    String[] parts = sdkUserAgent.split(&quot;\\s+&quot;);</span>

    // User Agent is in format:
    // product/product-version databricks-sdk-java/sdk-version jvm/jvm-version other-info
    // Remove the SDK part from user agent
<span class="fc" id="L274">    StringBuilder mergedString = new StringBuilder();</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">    for (int i = 0; i &lt; parts.length; i++) {</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">      if (parts[i].startsWith(SDK_USER_AGENT)) {</span>
<span class="fc" id="L277">        mergedString.append(JDBC_HTTP_USER_AGENT);</span>
      } else {
<span class="fc" id="L279">        mergedString.append(parts[i]);</span>
      }
<span class="fc bfc" id="L281" title="All 2 branches covered.">      if (i != parts.length - 1) {</span>
<span class="fc" id="L282">        mergedString.append(&quot; &quot;); // Add space between parts</span>
      }
    }
<span class="fc" id="L285">    return mergedString.toString();</span>
  }

  /** Reset the instance of the http client. This is used for testing purposes only. */
  @VisibleForTesting
  public static synchronized void resetInstance() {
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">    if (instance != null) {</span>
      try {
<span class="fc" id="L293">        instance.httpClient.close();</span>
<span class="fc" id="L294">      } catch (IOException e) {</span>
<span class="fc" id="L295">        LOGGER.error(&quot;Caught error while closing http client&quot;, e);</span>
<span class="fc" id="L296">      }</span>
<span class="fc" id="L297">      instance = null;</span>
    }
<span class="fc" id="L299">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>