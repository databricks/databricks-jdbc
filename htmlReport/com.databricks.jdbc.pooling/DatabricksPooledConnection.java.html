<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DatabricksPooledConnection.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jacoco.exec</a> &gt; <a href="index.source.html" class="el_package">com.databricks.jdbc.pooling</a> &gt; <span class="el_source">DatabricksPooledConnection.java</span></div><h1>DatabricksPooledConnection.java</h1><pre class="source lang-java linenums">package com.databricks.jdbc.pooling;

import com.databricks.jdbc.core.DatabricksSQLException;
import com.databricks.jdbc.core.IDatabricksConnection;
import com.databricks.jdbc.core.IDatabricksStatement;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.sql.*;
import java.util.HashSet;
import java.util.Set;
import javax.annotation.Nullable;
import javax.sql.ConnectionEvent;
import javax.sql.ConnectionEventListener;
import javax.sql.PooledConnection;
import javax.sql.StatementEventListener;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class DatabricksPooledConnection implements PooledConnection {

<span class="fc" id="L23">  private static final Logger LOGGER = LogManager.getLogger(DatabricksPooledConnection.class);</span>
<span class="fc" id="L24">  private final Set&lt;ConnectionEventListener&gt; listeners = new HashSet&lt;&gt;();</span>
  private Connection physicalConnection;
  private ConnectionHandler connectionHandler;

  public Connection getPhysicalConnection() {
<span class="fc" id="L29">    return this.physicalConnection;</span>
  }

  /**
   * Creates a new PooledConnection representing the specified physical connection.
   *
   * @param physicalConnection connection
   */
<span class="fc" id="L37">  public DatabricksPooledConnection(Connection physicalConnection) {</span>
<span class="fc" id="L38">    this.physicalConnection = physicalConnection;</span>
<span class="fc" id="L39">  }</span>

  /** Fires a connection closed event to all listeners. */
  void fireConnectionClosed() {
<span class="fc" id="L43">    LOGGER.debug(&quot;void fireConnectionClosed()&quot;);</span>
<span class="fc bfc" id="L44" title="All 2 branches covered.">    for (ConnectionEventListener listener : this.listeners) {</span>
<span class="fc" id="L45">      listener.connectionClosed(new ConnectionEvent(this));</span>
<span class="fc" id="L46">    }</span>
<span class="fc" id="L47">  }</span>

  /**
   * Fires a connection error event to all listeners
   *
   * @param e the SQLException to consider
   */
  private void fireConnectionError(SQLException e) {
<span class="fc" id="L55">    LOGGER.debug(&quot;private void fireConnectionError(SQLException e = {})&quot;, e.toString());</span>
<span class="pc bpc" id="L56" title="1 of 2 branches missed.">    for (ConnectionEventListener listener : this.listeners) {</span>
<span class="nc" id="L57">      listener.connectionErrorOccurred(new ConnectionEvent(this, e));</span>
<span class="nc" id="L58">    }</span>
<span class="fc" id="L59">  }</span>

  @Override
  public void addConnectionEventListener(ConnectionEventListener connectionEventListener) {
<span class="fc" id="L63">    listeners.add(connectionEventListener);</span>
<span class="fc" id="L64">  }</span>

  @Override
  public void removeConnectionEventListener(ConnectionEventListener connectionEventListener) {
<span class="fc" id="L68">    listeners.remove(connectionEventListener);</span>
<span class="fc" id="L69">  }</span>

  @Override
  public void removeStatementEventListener(StatementEventListener listener) {
    // Do nothing, not supported
<span class="fc" id="L74">  }</span>

  @Override
  public void addStatementEventListener(StatementEventListener listener) {
    // Do nothing, not supported
<span class="fc" id="L79">  }</span>

  /** Close the physical connection once the pooled connection is closed */
  @Override
  public void close() throws SQLException {
<span class="fc" id="L84">    LOGGER.debug(&quot;public void close()&quot;);</span>
<span class="pc bpc" id="L85" title="1 of 4 branches missed.">    if (connectionHandler != null &amp;&amp; !connectionHandler.isClosed()) {</span>
<span class="fc" id="L86">      connectionHandler.close();</span>
    }
<span class="pc bpc" id="L88" title="1 of 2 branches missed.">    if (physicalConnection == null) {</span>
<span class="nc" id="L89">      return;</span>
    }
    try {
<span class="fc" id="L92">      physicalConnection.close();</span>
    } finally {
<span class="fc" id="L94">      physicalConnection = null;</span>
    }
<span class="fc" id="L96">  }</span>

  /**
   * Gets a handle for a client to use. This is a wrapper around the physical connection, so the
   * client can call close, and it will just return the connection to the pool without really
   * closing the physical connection.
   *
   * &lt;p&gt;According to the JDBC 4.3 Optional Package spec (11.4), only one client may have an active
   * handle to the connection at a time, so if there is a previous handle active when this is
   * called, the previous one is forcibly closed.
   */
  @Override
  public Connection getConnection() throws SQLException {
<span class="fc" id="L109">    LOGGER.debug(&quot;public Connection getConnection()&quot;);</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">    if (physicalConnection == null) {</span>
      // Before throwing the exception, notify the listeners
<span class="fc" id="L112">      DatabricksSQLException sqlException =</span>
          new DatabricksSQLException(&quot;This PooledConnection has already been closed.&quot;);
<span class="fc" id="L114">      fireConnectionError(sqlException);</span>
<span class="fc" id="L115">      throw sqlException;</span>
    }
    // Only one connection can be open at a time from this PooledConnection
<span class="pc bpc" id="L118" title="3 of 4 branches missed.">    if (connectionHandler != null &amp;&amp; !connectionHandler.isClosed()) {</span>
<span class="nc" id="L119">      connectionHandler.close();</span>
    }
<span class="fc" id="L121">    connectionHandler = new ConnectionHandler(physicalConnection);</span>
<span class="fc" id="L122">    return connectionHandler.getVirtualConnection();</span>
  }

  /**
   * Instead of declaring a class implementing Connection, use a dynamic proxy to handle all calls
   * through the Connection interface.
   */
  private class ConnectionHandler implements InvocationHandler {
<span class="fc" id="L130">    private final Logger CONNECTION_HANDLER_LOGGER = LogManager.getLogger(ConnectionHandler.class);</span>
    private Connection physicalConnection;
    private Connection
        virtualConnection; // the Connection the client is currently using, which is not a physical

    // connection

<span class="fc" id="L137">    ConnectionHandler(Connection physicalConnection) {</span>
<span class="fc" id="L138">      this.physicalConnection = physicalConnection;</span>
      // Use a proxy connection object as a virtual connection, so that we do not close the physical
      // connection
<span class="fc" id="L141">      this.virtualConnection =</span>
          (Connection)
<span class="fc" id="L143">              Proxy.newProxyInstance(</span>
<span class="fc" id="L144">                  getClass().getClassLoader(),</span>
                  new Class[] {Connection.class, IDatabricksConnection.class},
                  this);
<span class="fc" id="L147">    }</span>

    @Override
    public Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable {
<span class="fc" id="L151">      CONNECTION_HANDLER_LOGGER.debug(</span>
          &quot;public Object invoke(Object proxy, Method method = {}, Object[] args = {})&quot;,
          method,
          args);
<span class="fc" id="L155">      final String methodName = method.getName();</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">      if (method.getDeclaringClass() == Object.class) {</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">        if (methodName.equals(&quot;toString&quot;)) {</span>
<span class="fc" id="L158">          return &quot;Pooled connection wrapping physical connection &quot; + physicalConnection;</span>
        }
<span class="fc bfc" id="L160" title="All 2 branches covered.">        if (methodName.equals(&quot;equals&quot;)) {</span>
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">          return proxy == args[0];</span>
        }
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">        if (methodName.equals(&quot;hashCode&quot;)) {</span>
<span class="fc" id="L164">          return System.identityHashCode(proxy);</span>
        }
        try {
<span class="nc" id="L167">          return method.invoke(physicalConnection, args);</span>
<span class="nc" id="L168">        } catch (InvocationTargetException e) {</span>
          // throwing.nullable
<span class="nc" id="L170">          throw e.getTargetException();</span>
        }
      }

<span class="fc bfc" id="L174" title="All 2 branches covered.">      if (methodName.equals(&quot;isClosed&quot;)) {</span>
<span class="pc bpc" id="L175" title="2 of 4 branches missed.">        return physicalConnection == null || physicalConnection.isClosed();</span>
      }
      // Do not close the physical connection, remove reference and fire close event
<span class="fc bfc" id="L178" title="All 2 branches covered.">      if (methodName.equals(&quot;close&quot;)) {</span>
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">        if (physicalConnection != null) {</span>
<span class="fc" id="L180">          physicalConnection = null;</span>
<span class="fc" id="L181">          virtualConnection = null;</span>
<span class="fc" id="L182">          connectionHandler = null;</span>
<span class="fc" id="L183">          fireConnectionClosed();</span>
        }
<span class="fc" id="L185">        return null;</span>
      }
<span class="pc bpc" id="L187" title="2 of 4 branches missed.">      if (physicalConnection == null || physicalConnection.isClosed()) {</span>
<span class="nc" id="L188">        throw new DatabricksSQLException(&quot;Connection has been closed.&quot;);</span>
      }

      // From here on in, we invoke via reflection and catch exceptions
      try {
        Class statementClass;
<span class="pc bpc" id="L194" title="2 of 4 branches missed.">        switch (methodName) {</span>
          case &quot;createStatement&quot;:
<span class="fc" id="L196">            statementClass = Statement.class;</span>
<span class="fc" id="L197">            break;</span>
          case &quot;prepareCall&quot;:
<span class="nc" id="L199">            statementClass = CallableStatement.class;</span>
<span class="nc" id="L200">            break;</span>
          case &quot;prepareStatement&quot;:
<span class="fc" id="L202">            statementClass = PreparedStatement.class;</span>
<span class="fc" id="L203">            break;</span>
          default:
<span class="nc" id="L205">            return method.invoke(physicalConnection, args);</span>
        }
<span class="fc" id="L207">        Statement st = (Statement) method.invoke(physicalConnection, args);</span>
<span class="fc" id="L208">        return Proxy.newProxyInstance(</span>
<span class="fc" id="L209">            getClass().getClassLoader(),</span>
            new Class[] {statementClass, IDatabricksStatement.class},
            new StatementHandler(this, st));
<span class="nc" id="L212">      } catch (final InvocationTargetException ite) {</span>
<span class="nc" id="L213">        final Throwable targetException = ite.getTargetException();</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">        if (targetException instanceof SQLException) {</span>
<span class="nc" id="L215">          fireConnectionError((SQLException) targetException);</span>
        }
<span class="nc" id="L217">        throw targetException;</span>
      }
    }

    Connection getVirtualConnection() {
<span class="fc" id="L222">      return virtualConnection;</span>
    }

    public void close() {
<span class="fc" id="L226">      CONNECTION_HANDLER_LOGGER.debug(&quot;public void close()&quot;);</span>
<span class="fc" id="L227">      physicalConnection = null;</span>
<span class="fc" id="L228">      virtualConnection = null;</span>
      // No close event fired here: see JDBC 4.3 Optional Package spec section 11.4
<span class="fc" id="L230">    }</span>

    public boolean isClosed() {
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">      return physicalConnection == null;</span>
    }
  }

  /**
   * Instead of declaring classes implementing Statement, use a dynamic proxy to handle all calls
   * through the Statement interfaces. The StatementHandler is required in order to return the
   * proper Connection proxy for the getConnection method.
   */
  private class StatementHandler implements InvocationHandler {
<span class="fc" id="L243">    private final Logger STATEMENT_HANDLER_LOGGER = LogManager.getLogger(StatementHandler.class);</span>
    private ConnectionHandler conHandler;
    private Statement physicalStatement;

<span class="fc" id="L247">    StatementHandler(ConnectionHandler conHandler, Statement physicalStatement) {</span>
<span class="fc" id="L248">      this.conHandler = conHandler;</span>
<span class="fc" id="L249">      this.physicalStatement = physicalStatement;</span>
<span class="fc" id="L250">    }</span>

    @Override
    public Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable {
<span class="fc" id="L254">      STATEMENT_HANDLER_LOGGER.debug(</span>
          &quot;public Object invoke(Object proxy = {}, Method method = {}, Object[] args = {})&quot;,
          proxy,
          method,
          args);
<span class="fc" id="L259">      final String methodName = method.getName();</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">      if (method.getDeclaringClass() == Object.class) {</span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">        if (methodName.equals(&quot;toString&quot;)) {</span>
<span class="fc" id="L262">          return &quot;Pooled statement wrapping physical statement &quot; + physicalStatement;</span>
        }
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">        if (methodName.equals(&quot;hashCode&quot;)) {</span>
<span class="fc" id="L265">          return System.identityHashCode(proxy);</span>
        }
<span class="nc bnc" id="L267" title="All 2 branches missed.">        if (methodName.equals(&quot;equals&quot;)) {</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">          return proxy == args[0];</span>
        }
<span class="nc" id="L270">        return method.invoke(physicalStatement, args);</span>
      }

<span class="fc bfc" id="L273" title="All 2 branches covered.">      if (methodName.equals(&quot;isClosed&quot;)) {</span>
<span class="pc bpc" id="L274" title="1 of 4 branches missed.">        return physicalStatement == null || physicalStatement.isClosed();</span>
      }
<span class="fc bfc" id="L276" title="All 2 branches covered.">      if (methodName.equals(&quot;close&quot;)) {</span>
<span class="pc bpc" id="L277" title="2 of 4 branches missed.">        if (physicalStatement == null || physicalStatement.isClosed()) {</span>
<span class="nc" id="L278">          return null;</span>
        }
<span class="fc" id="L280">        conHandler = null;</span>
<span class="fc" id="L281">        physicalStatement.close();</span>
<span class="fc" id="L282">        physicalStatement = null;</span>
<span class="fc" id="L283">        return null;</span>
      }
<span class="pc bpc" id="L285" title="1 of 4 branches missed.">      if (physicalStatement == null || physicalStatement.isClosed()) {</span>
<span class="fc" id="L286">        throw new DatabricksSQLException(&quot;Statement has been closed.&quot;);</span>
      }
<span class="fc bfc" id="L288" title="All 2 branches covered.">      if (methodName.equals(&quot;getConnection&quot;)) {</span>
<span class="fc" id="L289">        return conHandler</span>
<span class="fc" id="L290">            .getVirtualConnection(); // the virtual connection from the connection handler</span>
      }

      // Delegate the call to the physical Statement.
      try {
<span class="fc" id="L295">        return method.invoke(physicalStatement, args);</span>
<span class="nc" id="L296">      } catch (final InvocationTargetException ite) {</span>
<span class="nc" id="L297">        final Throwable targetException = ite.getTargetException();</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">        if (targetException instanceof SQLException) {</span>
<span class="nc" id="L299">          fireConnectionError((SQLException) targetException);</span>
        }
<span class="nc" id="L301">        throw targetException;</span>
      }
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>